{"meta":{"title":"Blog of Orange","subtitle":"Swimming in the code sea","description":null,"author":"CodeOrangeXD","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"线性表的基本操作","slug":"线性表的基本操作","date":"2019-10-26T05:51:48.000Z","updated":"2019-10-26T05:55:23.493Z","comments":true,"path":"2019/10/26/线性表的基本操作/","link":"","permalink":"http://yoursite.com/2019/10/26/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"环境 vs2015 线性表的基本操作 头文件 1234567891011121314151617181920212223242526272829#pragma once#define bool int#define LIST_INT_SIZE 100 //初始尺寸为100 B#define LIST_INCREAMENT 10 //每次增量为10 Btypedef enum Status&#123; success, fail, fatal, range_error&#125;Status;typedef int ElemType; //假设处理的数据类型为整形typedef struct SqList&#123; ElemType *elem; int length; int list_size;&#125;SqList, *Ptr, *SqListPtr;Status List_Init(SqListPtr L); void List_Destory(SqListPtr L); void List_Clear(SqListPtr L);bool List_Empty(SqListPtr L); int List_Size(SqListPtr L);Status List_Retrival(SqListPtr L, int pos, ElemType *elem);Status List_Locate(SqListPtr L, ElemType elem, int *pos); Status List_Insert(SqListPtr L, int pos, ElemType elem);Status List_delete(SqListPtr L, int pos); Status List_Prior(SqListPtr L, int pos, ElemType * elem); Status List_Next(SqListPtr L, int pos, ElemType *elem); .c文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&quot;SqList.h&quot;//初始化线性表Status List_Init(SqListPtr L) &#123; Status s = fail; if (L == NULL) &#123; L-&gt;elem = (ElemType*)malloc((LIST_INT_SIZE+1)*sizeof(ElemType)); if (L-&gt;elem) &#123; L-&gt;list_size = LIST_INT_SIZE; L-&gt;length = 0; s = success; &#125; &#125; return s;&#125;//归还线性表void List_Destory(SqListPtr L)&#123; if (L) &#123; if (L-&gt;elem) &#123; free(L-&gt;elem); L-&gt;elem = NULL; L-&gt;length = 0; &#125; &#125;&#125;//清空线性表void List_Clear(SqListPtr L)&#123; if (L) &#123; L-&gt;length = 0; &#125;&#125;//判断线性表是否为空bool List_Empty(SqListPtr L)&#123; return L-&gt;length;&#125;//线性表的长度int List_Size(SqListPtr L)&#123; return L-&gt;length;&#125;//在线性表L的pos这个位置读取元素 将元素放入elem变量中Status List_Retrival(SqListPtr L, int pos, ElemType *elem)&#123; Status s = range_error; if (L) &#123; if (pos&gt;=0 &amp;&amp; pos &lt;= L-&gt;length) &#123; *elem = L-&gt;elem[pos]; s = success; &#125; &#125; return s;&#125;//在线性表L当中 查找elem元素 如果找到了 将位置放入pos里Status List_Locate(SqListPtr L, ElemType elem, int *pos)&#123; Status s = range_error; int i = 1; if (L) &#123; for (i = 1; i &lt;= L-&gt;length;i++) &#123; if (L-&gt;elem[i] == elem) &#123; *pos = i; s = success; break; &#125; &#125; &#125; return s; &#125;//在线性表L当中 第pos个位置插入元素elemStatus List_Insert(SqListPtr L, int pos, ElemType elem)&#123; Status s = range_error; int i; if (L) &#123; if (pos &gt;= 1 &amp;&amp; pos&lt;=L-&gt;length+1) &#123; if (L-&gt;length &lt; L-&gt;list_size) &#123; for ( i = L-&gt;length; i &gt;= pos; i--) &#123; L-&gt;elem[i + 1] = L-&gt;elem[i]; L-&gt;elem[i] = pos; L-&gt;length = L-&gt;length + 1; s = success; &#125; &#125; &#125; &#125; return s;&#125;//在线性表L当中 删除pos位置的元素Status List_delete(SqListPtr L, int pos)&#123; Status s = range_error; int i; if (L) &#123; if (pos &gt;= 1 &amp;&amp; pos&lt;=L-&gt;length) &#123; for ( i = pos; i &lt;= L-&gt;length; i++) &#123; L-&gt;elem[i - 1] = L-&gt;elem[i]; L-&gt;length--; s = success; &#125; &#125; &#125; return s;&#125;//在线性表L当中 查找pos位置的前驱 放入elem当中Status List_Prior(SqListPtr L, int pos, ElemType * elem)&#123; Status s = range_error; if (L) &#123; if (pos &gt;= 2 &amp;&amp; pos&lt;=L-&gt;length) &#123; *elem = L-&gt;elem[pos - 1]; s = success; &#125; &#125; return s;&#125;//在线性表L当中 查找pos位置的后继 放入elem当中Status List_Next(SqListPtr L, int pos, ElemType *elem)&#123; Status s = range_error; if (L) &#123; if (pos &gt;= 1 &amp;&amp; pos&lt; L-&gt;length) &#123; *elem = L-&gt;elem[pos + 1]; s = success; &#125; &#125; return s;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"c","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"树的遍历应用","slug":"树的遍历应用","date":"2019-10-22T02:11:32.000Z","updated":"2019-10-22T02:19:15.587Z","comments":true,"path":"2019/10/22/树的遍历应用/","link":"","permalink":"http://yoursite.com/2019/10/22/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%BA%94%E7%94%A8/","excerpt":"","text":"遍历一个根目录下所有文件中的文件个数并打印 应用一个Directory[]数组存放目录个数，先根遍历所有文件 不足之处： 数组大小不可知 12345678910111213141516171819202122232425262728293031323334353637383940package 文件操作2;import java.io.*;public class demo &#123; public static void main(String[] args) &#123; int count = 0; //数组长度 String s=&quot;C:\\\\Users\\\\14421\\\\Desktop\\\\新建文件夹&quot;; File file=new File(s); File filelist[]=file.listFiles(); File Directory[]=new File[12]; try &#123; for(int i=0;i&lt;filelist.length;i++) &#123; if(filelist[i].isDirectory()) &#123; Directory[count]=filelist[i]; count++; &#125;else &#123; System.out.println(filelist[i]); &#125; &#125; for(int i=0;i&lt;count;i++) &#123; File file1=new File(Directory[i].getAbsolutePath()); File filelist1[]=file1.listFiles(); for(int j=0;j&lt;filelist1.length;j++) &#123; if(filelist1[j].isDirectory()) &#123; Directory[count]=filelist1[j]; count++; &#125;else &#123; System.out.println(filelist1[j]); &#125; &#125; &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/%E6%A0%91/"}]},{"title":"多线程","slug":"多线程","date":"2019-10-17T00:50:14.000Z","updated":"2019-10-17T01:02:50.260Z","comments":true,"path":"2019/10/17/多线程/","link":"","permalink":"http://yoursite.com/2019/10/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"线程的构造方法中 new出所需要的线程的个数，setPriority方法设置线程的优先级。 使用 对象=new Thread(new Runnable(){})设置线程 Runnable对象中包含run(){}方法 使用对象.start();调用线程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import javax.swing.*;import java.awt.*;public class threads extends JFrame &#123; private Thread threadA; private Thread threadB; private Thread threadC; private Thread threadD; final JProgressBar progressBar1=new JProgressBar(); final JProgressBar progressBar2=new JProgressBar(); final JProgressBar progressBar3=new JProgressBar(); final JProgressBar progressBar4=new JProgressBar(); public static void main(String[] args) &#123; init(new threads(),1000,1000); &#125; public threads() &#123; super(); getContentPane().add(progressBar1,BorderLayout.NORTH); getContentPane().add(progressBar2,BorderLayout.CENTER); getContentPane().add(progressBar3,BorderLayout.AFTER_LAST_LINE); getContentPane().add(progressBar4,BorderLayout.SOUTH); progressBar1.setStringPainted(true); progressBar2.setStringPainted(true); progressBar3.setStringPainted(true); progressBar4.setStringPainted(true); threadA=new Thread(new MyThread(progressBar1)); threadB=new Thread(new MyThread(progressBar2)); threadC=new Thread(new MyThread(progressBar3)); threadD=new Thread(new MyThread(progressBar4)); setPriority(&quot;threadA&quot;,5,threadA); setPriority(&quot;threadB&quot;,5,threadB); setPriority(&quot;threadC&quot;,4,threadC); setPriority(&quot;threadD&quot;,3,threadD); &#125; public static void setPriority(String threadName,int priority,Thread t) &#123; t.setPriority(priority); t.setName(threadName); t.start(); &#125; private final class MyThread implements Runnable&#123; private final JProgressBar bar; int count=0; private MyThread(JProgressBar bar) &#123; this.bar=bar; &#125; public void run() &#123; while(true) &#123; bar.setValue(count+=10); try &#123; Thread.sleep(1000); &#125;catch(Exception e) &#123; System.out.println(&quot;当前线程被中断&quot;); &#125; &#125; &#125; &#125; public static void init(JFrame frame,int width,int height) &#123; frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(width,height); frame.setVisible(true); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"threads","slug":"threads","permalink":"http://yoursite.com/tags/threads/"}]},{"title":"图的遍历","slug":"图的遍历","date":"2019-10-10T00:50:07.000Z","updated":"2019-10-10T01:07:34.866Z","comments":true,"path":"2019/10/10/图的遍历/","link":"","permalink":"http://yoursite.com/2019/10/10/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"1.图的遍历分为两种 .深度优先遍历 .广度优先遍历 *1.深度优先遍历* 类似于树的先根遍历，又有所不同，二叉树是层次形结构，所以不需要考虑重复遍历的情况 图则不同，要考虑重复遍历的过程 以下给出一种思路： 1234创建队列 任意取一个节点放入队列，然后将该节点的未被遍历过的第一个节点放入队列， 然后再以该节点的未被遍历过的第一个节点放入队列，重复此过程。 （与二叉树不同的是遍历时要考虑不能重复遍历） 2.广度优先遍历 广度优先遍历是一种层次型遍历 思路如下 123以任意一个（或多个节点）为第一层再以与该节点相邻的节点为第二层重复此过程","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图","slug":"图","permalink":"http://yoursite.com/tags/%E5%9B%BE/"}]},{"title":"抽象类与接口","slug":"抽象类与接口","date":"2019-10-10T00:34:07.000Z","updated":"2019-10-10T00:45:39.112Z","comments":true,"path":"2019/10/10/抽象类与接口/","link":"","permalink":"http://yoursite.com/2019/10/10/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"1.抽象类不允许初始化，只能被继承。 2.接口中的属性必须初始化，相当于常量。 3.接口被继承时使用implements关键字。 4.接口中的放法被重载时必须加上public。 12345678910111213141516171819202122232425262728293031323334interface demo2&#123; int age2=2; void Print(); static void write() &#123; System.out.println(age2); &#125;&#125;abstract class demo1&#123; int age1; abstract void text();&#125;public class demo extends demo1 implements demo2&#123; void text() &#123; System.out.println(age1); &#125; public void Print() &#123; System.out.println(age2); &#125; public static void main(String[] args) &#123; demo d1=new demo(); d1.age1=3; d1.text(); d1.Print(); //报错 //d1.write(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"接口 抽象类","slug":"接口-抽象类","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"}]},{"title":"类的继承","slug":"类的继承2-1","date":"2019-10-08T01:36:58.000Z","updated":"2019-10-10T00:17:21.745Z","comments":true,"path":"2019/10/08/类的继承2-1/","link":"","permalink":"http://yoursite.com/2019/10/08/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF2-1/","excerpt":"","text":"1.类在继承时不允许多重继承（即一个子类只允许有一个父类） 2.父类的静态方法在子类中可以直接调用 3.父类的非静态方法在调用时必须使用 对象.方法使用。 Example: 1234567891011121314151617181920212223242526272829303132333435363738class parent&#123; static void drawone()&#123; System.out.println(&quot;****************&quot;); &#125; static void drawtwo() &#123; System.out.println(&quot;xxxxxxxxxxxxxxxxx&quot;); &#125; void drawthree() &#123; System.out.println(&quot;mmmmmmmmmmmmmmmmmmmmm&quot;); &#125; parent(String x)&#123; System.out.println(x); &#125;&#125;abstract class demo1&#123; int age; abstract void text();&#125;public class demo extends parent&#123; static void drawtwo() &#123; System.out.println(&quot;zzzzzzzzzzzzzzzzzzzzz&quot;); &#125; demo()&#123; super(&quot;ttttt&quot;); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub\\ drawone(); drawtwo(); demo d=new demo(); d.drawthree(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"java文件类","slug":"java文件类","date":"2019-09-24T01:18:48.000Z","updated":"2019-09-24T01:28:31.298Z","comments":true,"path":"2019/09/24/java文件类/","link":"","permalink":"http://yoursite.com/2019/09/24/java%E6%96%87%E4%BB%B6%E7%B1%BB/","excerpt":"","text":"数据流相当与传输直接的通道 调用Creatnewfile()时必须加上异常处理 使用FileInputStream与FileOutputStream类是必须加上异常处理 FileInputStream是从文件中读取字节为单位的数据 FileOutputStream是也入文件以字节为单位 For Example 123456789101112131415161718192021222324252627282930313233import java.io.File;import java.io.FileInputStream;public class demo &#123; public static void main(String[] args) &#123; String filepath=&quot;D:/mytext.txt&quot;; File file=new File(filepath); //创建文件 try &#123; file.createNewFile(); &#125;catch(Exception e) &#123; e.getMessage(); &#125; if(file.exists()) &#123; System.out.println(&quot;文件已经创建&quot;); long length=file.length(); System.out.println(length); try &#123; FileInputStream fileinput=new FileInputStream(file); byte array[]=new byte[(int)length]; int len=fileinput.read(array); System.out.println(&quot;文件中的内容为：&quot;+new String(array,0,len)); fileinput.close(); &#125;catch(Exception e) &#123; e.getMessage(); &#125; &#125;else &#123; System.out.println(&quot;失败&quot;); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"I/O流","slug":"I-O流","permalink":"http://yoursite.com/tags/I-O%E6%B5%81/"}]},{"title":"关键字super的用法以及访问修饰符的作用","slug":"关键字super的用法","date":"2019-09-23T03:07:47.000Z","updated":"2019-10-26T05:59:35.578Z","comments":true,"path":"2019/09/23/关键字super的用法/","link":"","permalink":"http://yoursite.com/2019/09/23/%E5%85%B3%E9%94%AE%E5%AD%97super%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"关键字super在子类的构造方法中，用来继承父类的属性。 访问修饰符的作用如下 访问包的位置 类 修饰 符 private protected public 本类 可见 可见 可见 同包其他类或子类 不可见 可见 可见 其他包的类或子类 不可见 不可见 可见 代码如下 123456789101112131415161718192021222324252627282930public class demo extends demo1 &#123; demo(int x,int y,int z)&#123; super(x,y,z); &#125; demo()&#123; super(); &#125; public static void main(String[] args) &#123; demo jc=new demo(1,100,1000); demo jz=new demo(); System.out.println(jc.y); System.out.println(jc.z); &#125;&#125;class demo1&#123; private int x=0; protected int y=1; public int z=2; demo1(int x,int y,int z)&#123; this.y=y; this.z=z; this.x=x; &#125; demo1()&#123; System.out.println(&quot;123&quot;); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"super 访问修饰符","slug":"super-访问修饰符","permalink":"http://yoursite.com/tags/super-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"}]},{"title":"Astah画类图","slug":"Astah画类图","date":"2019-09-15T13:32:03.000Z","updated":"2019-09-15T13:38:20.427Z","comments":true,"path":"2019/09/15/Astah画类图/","link":"","permalink":"http://yoursite.com/2019/09/15/Astah%E7%94%BB%E7%B1%BB%E5%9B%BE/","excerpt":"","text":"使用Astah画类图如下 黄点 代表属性 绿杠 代表方法 使用Tools--java--export 可以导出.java文件","categories":[{"name":"Astah","slug":"Astah","permalink":"http://yoursite.com/categories/Astah/"}],"tags":[]},{"title":"类的继承1","slug":"类的继承","date":"2019-09-14T05:35:57.000Z","updated":"2019-10-10T00:19:00.388Z","comments":true,"path":"2019/09/14/类的继承/","link":"","permalink":"http://yoursite.com/2019/09/14/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/","excerpt":"","text":"类在继承时有以下几个注意点 1. 含有主函数的类叫做主类。主类命必须与文件命相同。 2. 其他类不可以有访问修饰符。 3. 用关键字extends。 4. 子类可以只实现父类部分功能。 For example 1234567891011121314151617181920212223242526package demo;class demo extends demo1&#123; public void write() &#123; System.out.println(&quot;再见&quot;); &#125; public static void main(String[] args)&#123; demo x= new demo(); x.write(); &#125;&#125;class demo1 &#123; public void draw() &#123; for(int i=0;i&lt;9;i++)&#123; System.out.print(i+&quot;\\t&quot;); &#125; System.out.println(); &#125; public void write() &#123; System.out.println(&quot;你好&quot;); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"继承 java","slug":"继承-java","permalink":"http://yoursite.com/tags/%E7%BB%A7%E6%89%BF-java/"}]},{"title":"BindarySearch","slug":"BindarySearch","date":"2019-09-10T01:15:50.000Z","updated":"2019-09-10T01:23:31.443Z","comments":true,"path":"2019/09/10/BindarySearch/","link":"","permalink":"http://yoursite.com/2019/09/10/BindarySearch/","excerpt":"","text":"思路： 创建一个队列，通过高 低下标来确定中间元素的下标，然后访问中间元素的值与要查找的值进行比较， 再通过具体情况来移动高低下标。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Scanner;public class BindaryFind &#123; public static void main(String[] args) &#123; // 二分法查找 //前提:数组有序 Scanner input=new Scanner(System.in); int[]nums=new int[] &#123;5,6,7,8,9,10,11,12,17,30,211&#125;; int high=nums.length-1; int low=0; int searchnum; for(int i=0;i&lt;nums.length;i++) &#123; System.out.print(nums[i]+&quot;\\t&quot;); &#125; System.out.println(); System.out.print(&quot;请输入要查找的数字：&quot;); searchnum=input.nextInt(); while((low&lt;=high))&#123; int mid=(high+low)/2; if(searchnum&lt;nums[low]||searchnum&gt;nums[high]) &#123; System.out.println(&quot;没有你要找的元素&quot;); break; &#125; if(searchnum&gt;nums[mid])&#123; low=mid+1; &#125; if(searchnum==nums[mid]) &#123; System.out.print(&quot;找到你要找到的数字,数组的第&quot;+(mid+1)+&quot;个元素&quot;); break; &#125; if(searchnum&lt;nums[mid]) &#123; high=mid-1; &#125; &#125; &#125;&#125;","categories":[{"name":"查找（java）","slug":"查找（java）","permalink":"http://yoursite.com/categories/%E6%9F%A5%E6%89%BE%EF%BC%88java%EF%BC%89/"}],"tags":[{"name":"二分法查找","slug":"二分法查找","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/"}]},{"title":"sort","slug":"sort","date":"2019-09-09T02:55:02.000Z","updated":"2019-09-09T03:12:49.664Z","comments":true,"path":"2019/09/09/sort/","link":"","permalink":"http://yoursite.com/2019/09/09/sort/","excerpt":"","text":"冒泡排序思路： 前一个元素和后一个元素比较，让后交换，每轮选取一个最值。 代码如下 123456789101112131415161718192021222324public class MaoPao &#123; public static void main(String[] args) &#123; // 冒牌排序 int temp; int nums[]= &#123;7,1,2,5,4&#125;; for(int i=0;i&lt;nums.length-1;i++) &#123; for(int j=0;j&lt;nums.length-1;j++) &#123; if(nums[j]&gt;nums[j+1]) &#123; temp=nums[j]; nums[j]=nums[j+1]; nums[j+1]=temp; &#125; &#125; &#125; for(int i=0;i&lt;nums.length;i++) &#123; System.out.print(nums[i]+&quot;\\t&quot;); &#125; &#125;&#125; 选择排序思路： 先创建一个控下标minindex，初值为数组的一个元素的index,然后第i个元素与后面的元素比较， 如果关系成立，则将最小的下标赋给minindex，最后交换。 代码如下 1234567891011121314151617181920212223public class Select &#123; public static void main(String[] args) &#123; // 选择排序 int nums[]= &#123;3,1,2,5,4&#125;; int temp; for(int i=0;i&lt;nums.length-1;i++)&#123; int minindex=i; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[minindex]&gt;nums[j])&#123; minindex=j; &#125; &#125; temp=nums[minindex]; nums[minindex]=nums[i]; nums[i]=temp; &#125; for(int i=0;i&lt;nums.length;i++) &#123; System.out.print(nums[i]+&quot;\\t&quot;); &#125; &#125;&#125; 反转排序思路： 第一个与最后一个元素交换，第二个和倒数第二个交换。。。。以此类推。 代码如下 1234567891011121314151617181920 public class Fanzhuan &#123; public static void main(String[] args) &#123; // 反转排序 int temp; int nums[]= &#123;3,4,5,6,7&#125;; for(int i=0;i&lt;nums.length/2;i++) &#123; temp=nums[i]; nums[i]=nums[nums.length-i-1]; nums[nums.length-i-1]=temp; &#125; for(int i=0;i&lt;nums.length;i++) &#123; System.out.print(nums[i]+&quot;\\t&quot;); &#125; &#125;&#125;","categories":[{"name":"排序（java）","slug":"排序（java）","permalink":"http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%EF%BC%88java%EF%BC%89/"}],"tags":[{"name":"选择排序 冒泡排序 反转排序 java","slug":"选择排序-冒泡排序-反转排序-java","permalink":"http://yoursite.com/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E5%8F%8D%E8%BD%AC%E6%8E%92%E5%BA%8F-java/"}]},{"title":"洗牌(java)","slug":"洗牌（java）","date":"2019-09-07T05:59:58.000Z","updated":"2019-09-07T12:55:04.058Z","comments":true,"path":"2019/09/07/洗牌（java）/","link":"","permalink":"http://yoursite.com/2019/09/07/%E6%B4%97%E7%89%8C%EF%BC%88java%EF%BC%89/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142public class WashCard &#123; public static void main(String[] args) &#123; final int N=52; int[] cards=new int[N]; String cardscolor[]= &#123;&quot;红桃&quot;,&quot;方块&quot;,&quot;黑桃&quot;,&quot;梅花&quot;&#125;; String cardsface[]= &#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&#125;; for(int i=0;i&lt;cards.length;i++)&#123; cards[i]=i; &#125; System.out.println(&quot;洗牌前：&quot;); for(int i=0;i&lt;cards.length;i++)&#123; System.out.print(cardsface[cards[i]%13]+&quot;-&quot;+cardscolor[cards[i]/13]); if((i+1)%13==0) &#123; System.out.println(); &#125;else &#123; System.out.print(&quot;\\t&quot;); &#125; &#125; //洗牌 for(int i=0;i&lt;cards.length;i++) &#123; int Index=(int)(Math.random()*N); // 0-51随机数字 int temp=cards[i]; cards[i]=cards[Index]; cards[Index]=temp; &#125; System.out.println(); System.out.println(&quot;洗牌后：&quot;); for(int i=0;i&lt;cards.length;i++)&#123; System.out.print(cardsface[cards[i]%13]+&quot;_&quot;+cardscolor[cards[i]/13]); if((i+1)%13==0) &#123; System.out.println(); &#125;else &#123; System.out.print(&quot;\\t&quot;); &#125; &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java应用","slug":"java应用","permalink":"http://yoursite.com/tags/java%E5%BA%94%E7%94%A8/"}]},{"title":"链表 实现录入学生信息","slug":"链表-实现录入学生信息","date":"2019-03-29T04:22:12.000Z","updated":"2019-03-29T15:37:55.628Z","comments":true,"path":"2019/03/29/链表-实现录入学生信息/","link":"","permalink":"http://yoursite.com/2019/03/29/%E9%93%BE%E8%A1%A8-%E5%AE%9E%E7%8E%B0%E5%BD%95%E5%85%A5%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF/","excerpt":"","text":"功能说明： 学生管理系统 录入学生的姓名和号码 当号码为0时退出录入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;//链表typedef struct LinkList&#123; char *name; int num; LinkList *next;&#125;*LK;LinkList *pHead;int count;void Creat();void Print();void Insert();void Delete();int main()&#123; char a; Creat(); Print(); do &#123; printf(&quot;请选择 Y：删除 N：插入 其他任意键退出\\n&quot;); printf(&quot;请输入：&quot;); fflush(stdin); a=getchar(); switch (a) &#123; case &apos;y&apos;: case &apos;Y&apos;: Delete(); Print(); break; case &apos;n&apos;: case &apos;N&apos;: Insert(); Print(); break; default: break; &#125; &#125; while (a==&apos;y&apos;||a==&apos;n&apos;||a==&apos;Y&apos;||a==&apos;N&apos;); return 0;&#125;void Creat() //录入函数&#123; pHead = NULL; LinkList *pNew; LinkList *pEnd; count = 0; pNew = pEnd = (LinkList*)malloc(sizeof(LinkList)); while (pNew-&gt;num != 0) &#123; count++; if (count == 1) &#123; pHead = pNew; pEnd = pNew; pNew-&gt;next = NULL; &#125; else &#123; pNew = (LinkList*)malloc(sizeof(LinkList)); pNew-&gt;next = NULL; pEnd-&gt;next = pNew; pEnd = pNew; &#125; pNew-&gt;name = (char*)malloc(sizeof(char)); printf(&quot;请输入学生姓名：&quot;); scanf(&quot;%s&quot;,pNew-&gt;name); printf(&quot;请输入学生号码：&quot;); scanf(&quot;%d&quot;, &amp;pNew-&gt;num); printf(&quot;***************************************\\n&quot;); &#125; count--; free(pEnd);&#125;void Print() //打印输出函数&#123; int i; LinkList *Temp; Temp = pHead; for (i = 0; i &lt; count; i++) &#123; printf(&quot;#%d\\n&quot;, i + 1); printf(&quot;学生的姓名为：%s\\n&quot;, Temp-&gt;name); printf(&quot;学生的号码为：%d\\n&quot;, Temp-&gt;num); Temp = Temp-&gt;next; &#125;&#125;void Insert()&#123; int i; int j; LinkList *Temp; LinkList *pNew; pNew = (LinkList*)malloc(sizeof(LinkList)); pNew-&gt;name = (char*)malloc(sizeof(char)); Temp = pHead; if (count!=0) &#123; printf(&quot;请输入先要在第几个元素后面插入：&quot;); scanf(&quot;%d&quot;, &amp;i); if (i &lt;= 0 || i &gt; count) &#123; printf(&quot;overflow\\n&quot;); exit(0); &#125; for (j = 1; j &lt; i; j++) &#123; Temp = Temp-&gt;next; &#125; printf(&quot;请输入要插入的学生的姓名：&quot;); scanf(&quot;%s&quot;, pNew-&gt;name); printf(&quot;请输入要插入的学生的号码：&quot;); scanf(&quot;%d&quot;, &amp;pNew-&gt;num); pNew-&gt;next = Temp-&gt;next; Temp-&gt;next = pNew; count++; &#125; else &#123; printf(&quot;请输入要插入的学生的姓名：&quot;); scanf(&quot;%s&quot;, pNew-&gt;name); printf(&quot;请输入要插入的学生的号码：&quot;); scanf(&quot;%d&quot;, &amp;pNew-&gt;num); pNew-&gt;next = NULL; pHead = pNew; count++; &#125;&#125;void Delete()&#123; int i,x;//来记录状态 LinkList *Temp1; LinkList *Temp2; Temp1 = pHead; Temp2 = pHead; char *name; name = (char*)malloc(sizeof(char)); printf(&quot;请输入要删除的人的姓名：&quot;); scanf(&quot;%s&quot;,name); if (*name==*(pHead-&gt;name)) &#123; pHead = pHead-&gt;next; count--; &#125; else &#123; for (i = 0; i &lt; count; i++) //找到此人 &#123; if (*(Temp1-&gt;name) != *name) &#123; printf(&quot;没有此人\\n&quot;); x = 1; &#125; else &#123; x = 0; break; &#125; Temp1 = Temp1-&gt;next; &#125; if (x == 0) &#123; for (i = 0; i &lt; count; i++) //找到他前一个人 &#123; if (Temp2-&gt;next == Temp1) &#123; break; &#125; Temp2 = Temp2-&gt;next; &#125; Temp2-&gt;next = Temp1-&gt;next; count--; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法 链表","slug":"算法-链表","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"}]},{"title":"栈的应用---进制转换","slug":"栈的应用-进制转换","date":"2019-03-28T11:34:09.000Z","updated":"2019-03-29T04:41:05.539Z","comments":true,"path":"2019/03/28/栈的应用-进制转换/","link":"","permalink":"http://yoursite.com/2019/03/28/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"思路： 1.创建一个空栈 2.将计算的结果循环入栈 3.将计算的结果循环出栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/////////10进制转2进制#include &quot;stdafx.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#define Stack_init_size 100#define ADDstack 10//创建一个栈 数据类型typedef struct Sqstack&#123; int *top; int *base; int stacksize;&#125;stack;//初始化一个栈 （构造一个空栈）void InitStack(Sqstack);//找到栈顶的函数int GetTop(Sqstack);//入栈函数int Push(Sqstack,int);//出栈函数int OutStack(Sqstack,int);int _tmain(int argc, _TCHAR* argv[])&#123; int x,y; printf(&quot;请输入要转换的数：&quot;); scanf(&quot;%d&quot;, &amp;x); void InitStack(Sqstack stack); do&#123; y = x % 2; x = x / 2; int Push(Sqstack stack, int y); int OutStack(Sqstack stack, int x); printf(&quot;%d\\t&quot;, y); &#125; while (x != 0); return 0;&#125;void Initstack(Sqstack stack)&#123; stack.base = (int*)malloc(Stack_init_size * sizeof(int)); //动态分配内存 if (!stack.base) // 判断栈是否存在 &#123; exit(0); &#125; stack.top = stack.base; stack.stacksize = Stack_init_size;&#125;int GetTop(Sqstack stack)&#123; int num; if (stack.base = stack.top) return -1; //取余不可能出现负1 所以-1表示错误标志 num = *(stack.top - 1); return num;&#125;int Push(Sqstack stack, int num)&#123; if (stack.top - stack.base &gt;= stack.stacksize) // 判段栈是否为满栈 &#123; stack.base = (int*)realloc(stack.base, (Stack_init_size + ADDstack)*sizeof(int)); if (!stack.base)exit(0); stack.top = stack.base + stack.stacksize; stack.stacksize += ADDstack; &#125; *stack.top++ = num; return 0;&#125;int OutStack(Sqstack stack, int num)&#123; if (stack.base == stack.top) return -2; // 判断栈是否为空栈 num = *--stack.top; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法 栈","slug":"算法-栈","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95-%E6%A0%88/"}]},{"title":"C语言 关于文件操作(3)","slug":"C语言-关于文件操作-3","date":"2019-03-28T05:04:07.000Z","updated":"2019-03-28T07:18:11.262Z","comments":true,"path":"2019/03/28/C语言-关于文件操作-3/","link":"","permalink":"http://yoursite.com/2019/03/28/C%E8%AF%AD%E8%A8%80-%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-3/","excerpt":"","text":"文件随机读写函数1.读入 函数原型： int fread(void *ptr,int size,int count,FILE *fp); 函数功能： fread()函数的功能是在fp指定的文件中读取count次数据项（每次size个字节） 存放到以ptr所指的内存单元地址中去。 返回值： 成功返回读入的块数，出错或者到尾部，返回0。 1fread(f,4,2,fp); 此函数从fp所指向的文件中读入2个4个字节的数据，存储到数组f中，若写入成功，此函数返回值为2。2.写入 函数原型： int fwrite(void *ptr,int size,int count,FILE *fp); 函数功能： fwrite()函数的功能是将从ptr为首地址的内存中取出count次数据项（每次size个字节） 写入fp所指的磁盘文件中。 返回值： 成功返回读入的块数，出错或者到尾部，返回0。 1fwrite(butter,16,64,fp); 此函数从fp所指向的文件中读入2个4个字节的数据，存储到数组f中去，若写入成功，此函数返回值为2。 文件的定位1.fseek函数 函数原型： int fseek(FILE *fp,long offset,int from); 函数功能： 用来控制文件的指针移动。 from： 起始位置。文件首部,当前位置和文件尾部分别对应0，1，2；或者常量 SEEK_SET,SEEK_CUR, SEEK_END。 offset： 以起始点为基点，向前移动的字节数。 返回值： 定位成功为0，不成功为非0的整数值。 1fseek(fp,100L,0); 将位置指针移动到离头文件100个字节处。 2.ftell函数 函数原型： long ftell(FILE *fp); 函数功能： 获取当前文件指针的位置，即相对于文件开头的位移量（字节数）。 返回值： 成功时，值大于等于0，即文件指针的当前指向。出错时，返回-1L。 12i = ftell(fp);if(i==-1L) printf(&quot;error\\n&quot;); 3.rewind()函数 函数原型： void rewind(FILE fp); 函数功能： 定位文件指针，使文件指针指向读写文件的首地址，即打开文件时文件 指针所指向的位置。*4.feof()函数** 函数原型： int feof(FILE *fp); 函数功能： 判断fp指针是否到文件尾部。 返回值： 返回值为1，表示到文件结束位置；返回值为0，表示文件未结束。 文件的错误检测1.ferror函数 函数原型： int ferror(FILE fp); 函数功能： 用来检查文件在用各种输入输出函数进行读写时是否出错。文件指针 必须是已经定义过的。 返回值： 若返回值为0，表示未出错，否则表示有错。 说明： 在调用一个输入输出函数后立即检查ferror函数的值，否则信息会丢失。 在执行fopen函数时，ferror函数的初始值自动置为0。*2.clearerr函数** 函数原型： void clearerr(FILE *fp); 函数功能： 用来清除出错标志和文件结束标志，使它们为0。 说明： 出错后，错误标志一直保留，直到对同一文件调用clearerr(fp)或rewind 或任何其他一个输入输出函数。","categories":[],"tags":[{"name":"fread fwrite fseek ftell rewind feof ferror clearerr","slug":"fread-fwrite-fseek-ftell-rewind-feof-ferror-clearerr","permalink":"http://yoursite.com/tags/fread-fwrite-fseek-ftell-rewind-feof-ferror-clearerr/"}]},{"title":"C语言 关于文件操作(2)","slug":"C语言-关于文件操作-2","date":"2019-03-27T07:05:21.000Z","updated":"2019-03-27T09:54:56.066Z","comments":true,"path":"2019/03/27/C语言-关于文件操作-2/","link":"","permalink":"http://yoursite.com/2019/03/27/C%E8%AF%AD%E8%A8%80-%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2/","excerpt":"","text":"字符串方式文件读写函数1.字符串的读入 fgets函数 函数原型：char *fgets(char *s,int n,FILE *fp) 功能： fgets()从fp所指文件读n-1个字符送入s(可以是字符数组名)指向的内存区，并自动在 最后加一个’\\0’。 返回值：正常，返回字符串的首地址；出错或文件尾，返回NULL。 2.fputs函数 函数原型：int fputs(char *s,FILE *fp) 功能： 把s所指向的字符串写入fp指向的文件，字符串的结束符’\\0’不写入文件。 返回值：正常，返回最后一个写入的字符，出错为EOF。 123456789101112131415161718FILE *fp;char str[20];if((fp=fopen(&quot;F:\\\\f1.txt&quot;,&quot;w+&quot;))==NULL)&#123; printf(&quot;can not open file&quot;); exit(0);&#125;printf(&quot;input a string\\n&quot;);while(strlen(gets(str))&gt;0)&#123; fputs(str,fp);&#125; rewind(fp);while(fgets(str,20,fp)!=NULL)&#123; fputs(str,stdout); //相当于puts(str);&#125;fclose(fp); 格式化文件读写1.读入 函数原型：int fscanf(FILE *fp,格式控制串，输入列表) 功能： fscanf()函数的功能是从fp指向的文件中，按格式控制串中的控制符读取相应数据赋给输入列表中对应的变量地址中。 返回值：成功，返回读入的个数，出错或文件尾，返回EOF。 12345FILE *fp; int n; float x; fp=fopen(&quot;F:\\\\f1.txt&quot;,&quot;r&quot;); fscanf(fp,&quot;%d%f&quot;,&amp;n,&amp;x);//表示从文件f1.txt中分别读入整形数到变量n，浮点数到变量x。 2.写入 函数原型：int fprintf(FILE *fp,格式控制串，输出列表) 功能： fprintf()函数的功能是按格式控制串中的控制符把相应数据写入fp指向的文件中。 返回值：成功，返回写入的个数，出错或文件尾，返回EOF。 123456FILE *fp;int n;float x;fp=fopen(&quot;F:\\\\f1.txt&quot;,&quot;w&quot;);fprintf(fp,&quot;%d%f&quot;,n,x);//表示把变量n和x的数值写入文件f1.txt。","categories":[],"tags":[{"name":"C语言 fgets fputs fscanf fprintf","slug":"C语言-fgets-fputs-fscanf-fprintf","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80-fgets-fputs-fscanf-fprintf/"}]},{"title":"C语言 关于文件操作(1)","slug":"C语言-关于文件操作-1","date":"2019-03-27T02:38:15.000Z","updated":"2019-10-26T06:07:08.179Z","comments":true,"path":"2019/03/27/C语言-关于文件操作-1/","link":"","permalink":"http://yoursite.com/2019/03/27/C%E8%AF%AD%E8%A8%80-%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1/","excerpt":"","text":"文件的打开与关闭1.文件的打开 fopen函数 调用格式： FILE *fp; fp=fopen(“文件的路径”,”文件的打开方式”)； 功能：fopen()打开一个指向文件名的文件夹，文件操作方式由打开方式的值决定。 返回值：正常打开时，返回一个指向该文件结构体的指针；若错误，返回错误标志NULL 文件打开方式： 文本文件 二进制文件 使用方式 含义 使用方式 含义 “r” 打开文件进行只读 “rb” 打开二进制文件进行只读 “w” 建立新文本进行只读 “wb” 建立新二进制文件进行只读 “a” 打开文本进行追加 “ab” 打开二进制文件进行追加 “r+” 打开文本文件进行读/写 “rb+” 打开二进制文件进行读/写 “w+” 建立新文本进行读/写 “wb+” 建立新二进制文件进行读/写 “a+” 打开文本进行读/写/追加 “ab+” 打开二进制文件进行读/写/追加 为了保证文件操作可靠性，一般在调用函数时做个判断。 12345if((fp = fopen(&quot;F:\\\\f1.txt&quot;,&quot;r&quot;))==NULL)&#123; printf(&quot;File open error!\\n&quot;); exit(0);&#125; 2.文件的关闭 fclose()函数 调用格式： fclose(文件指针); 功能：关闭打开的文件 返回值：若成功关闭，返回一个0值，否则返回一个非零值。 12345if(fclose(fp))&#123; printf(&quot;Can not close the file!\\n&quot;); exig(0);&#125; 文件的读写1.字符的读入 fgetc函数 函数原型：int fgetc(FILE *fp) 功能：从fp指向的文件中读取一字节代码。 返回值：正常，返回读到的代码值；读到尾部或者出错，为EOF。 //EOF为常量，其值为-1（EOF在 stdio.h 中有说明） 2.字符的写入 fputc函数 函数原型：int fputc(int c,FILE *fp) 功能：把一个字节c写入fp指向的文件中。 返回值：正常，返回c;出错返回EOF。 1234567891011121314151617181920212223242526272829303132333435FILE *fp; char c; int i; fp = fopen(&quot;F://f1.txt&quot;, &quot;w+&quot;); if (fp == NULL) &#123; printf(&quot;file open error!\\n&quot;); exit(0); &#125; printf(&quot;input a string\\n&quot;); c = getchar(); while (c != &apos;#&apos;) /*输入字符以#结束*/ &#123; fputc(c, fp); /*将输入的字符写入文件*/ c = getchar(); &#125; rewind(fp); /*用于把指针fp所指的文件的内部位置的指针移动到文件头*/ fflush(stdin); c = getchar(); while (c != EOF) /*读文件，并测试是否到文件尾巴*/ &#123; putchar(c); c = fgetc(fp); &#125; if (fclose(fp)) /*正常关闭*/ &#123; printf(&quot;can not close the fil!\\n&quot;); exit(0); &#125; fputc(&apos;b&apos;, fp); fclose(fp);","categories":[],"tags":[{"name":"C语言 fopen fclose fgetc fputc","slug":"C语言-fopen-fclose-fgetc-fputc","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80-fopen-fclose-fgetc-fputc/"}]}]}